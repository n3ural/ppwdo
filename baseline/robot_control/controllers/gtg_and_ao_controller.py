from math import pi, atan2
from baseline.utils import linalg2_util as linalg
from baseline.robot_control.controllers.avoid_obstacles_controller import AvoidObstaclesController
from baseline.robot_control.controllers.go_to_goal_controller import GoToGoalController


class GTGAndAOController:
    """
    The GTGAndAOController class blends the functionalities of the "Go To Goal" (GTG) and "Avoid Obstacles" (AO) controllers.
    It offers a hybrid control strategy, guiding a robot towards a target position while avoiding obstacles in its path.
    By determining a blending factor, the controller computes a weighted heading vector combining both the GTG and AO strategies.
    The class interfaces with a supervisor to obtain essential data, such as the robot's current pose, sensor information, and time stamps.
    """

    def __init__(self, supervisor):
        """
        Initialize the GTGAndAOController with a reference to the supervisor.

        Sets up control gains, initializes key vectors for obstacle avoidance and goal direction, and
        instantiates the GoToGoal and AvoidObstacles controllers. It also defines sensor gains for obstacle detection
        and determines a blending factor for the two strategies.

        Parameters
        ----------
        supervisor : object
            The supervisor instance that this controller will interact with and obtain necessary data from.
        """

        # bind the supervisor
        self.supervisor = supervisor

        # initialize controllers to blend
        self.go_to_goal_controller = GoToGoalController(supervisor)
        self.avoid_obstacles_controller = AvoidObstaclesController(supervisor)

        # sensor gains (weights)
        self.avoid_obstacles_controller.sensor_gains = [
            1.0 - ((0.4 * abs(p.theta)) / pi)
            for p in self.avoid_obstacles_controller.proximity_sensor_placements
        ]

        # blending factor
        # go-to-goal heading is given this much weight, avoid-obstacles is given the
        # remaining weight
        self.alpha = 0.1

        # control gains
        self.kP = 10.0
        self.kI = 0.0
        self.kD = 0.0

        # stored values - for computing next results
        self.prev_time = 0.0
        self.prev_eP = 0.0
        self.prev_eI = 0.0

        # key vectors and data (initialize to any non-zero vector)
        self.obstacle_vectors = [[1.0, 0.0]] * len(
            self.avoid_obstacles_controller.proximity_sensor_placements
        )
        self.ao_heading_vector = [1.0, 0.0]
        self.gtg_heading_vector = [1.0, 0.0]
        self.blended_heading_vector = [1.0, 0.0]

    def update_heading(self):
        """
        Compute and store heading vectors from both the GTG and AO controllers.

        This method calculates the heading vectors from the GoToGoal and AvoidObstacles controllers. The vectors
        are then normalized and stored for subsequent control operations. The blending of the vectors is determined
        by the blending factor, ensuring the robot moves towards its goal while avoiding obstacles.
        """

        # generate and store the vectors generated by the two controller types
        self.gtg_heading_vector = (
            self.go_to_goal_controller.calculate_gtg_heading_vector()
        )
        (
            self.ao_heading_vector,
            self.obstacle_vectors,
        ) = self.avoid_obstacles_controller.calculate_ao_heading_vector()

        # normalize the heading vectors
        self.gtg_heading_vector = linalg.unit(self.gtg_heading_vector)
        self.ao_heading_vector = linalg.unit(self.ao_heading_vector)

        # generate the blended vector
        self.blended_heading_vector = linalg.add(
            linalg.scale(self.gtg_heading_vector, self.alpha),
            linalg.scale(self.ao_heading_vector, 1.0 - self.alpha),
        )

    def execute(self):
        """
        Implement the blended control strategy to guide the robot towards its goal while avoiding obstacles.

        This method computes the time elapsed since the last control iteration, derives error terms for PID control
        based on the blended heading vector, calculates the required angular and translational velocities, and sets
        the robot's outputs. The robot is guided in the direction of the target goal while avoiding obstacles based
        on the combined heading vector.
        """

        # calculate the time that has passed since the last control iteration
        current_time = self.supervisor.time()
        dt = current_time - self.prev_time

        # calculate the error terms
        theta_d = atan2(self.blended_heading_vector[1], self.blended_heading_vector[0])
        eP = theta_d
        eI = self.prev_eI + eP * dt
        eD = (eP - self.prev_eP) / dt

        # calculate angular velocity
        omega = self.kP * eP + self.kI * eI + self.kD * eD

        # calculate translational velocity
        # velocity is v_max when omega is 0,
        # drops rapidly to zero as |omega| rises
        v = self.supervisor.v_max() / (abs(omega) + 1) ** 1.5

        # store values for next control iteration
        self.prev_time = current_time
        self.prev_eP = eP
        self.prev_eI = eI

        self.supervisor.set_outputs(v, omega)

        # === FOR DEBUGGING ===
        # self._print_vars( eP, eI, eD, v, omega )

    def _print_vars(self, eP, eI, eD, v, omega):
        """
        Print control and error variables for debugging purposes.

        Outputs various control components, error terms, and robot outputs to the console. Useful for debugging
        and tracking the robot's control behavior during execution.

        Parameters
        ----------
        eP : float
            Proportional error term.
        eI : float
            Integral error term.
        eD : float
            Derivative error term.
        v : float
            Translational velocity of the robot.
        omega : float
            Angular velocity of the robot.
        """

        print("\n\n")
        print("==============")
        print("ERRORS:")
        print("eP: " + str(eP))
        print("eI: " + str(eI))
        print("eD: " + str(eD) + "\n")
        print("CONTROL COMPONENTS:")
        print("kP * eP = " + str(self.kP) + " * " + str(eP))
        print("= " + str(self.kP * eP))
        print("kI * eI = " + str(self.kI) + " * " + str(eI))
        print("= " + str(self.kI * eI))
        print("kD * eD = " + str(self.kD) + " * " + str(eD))
        print("= " + str(self.kD * eD) + "\n")
        print("OUTPUTS:")
        print("omega: " + str(omega))
        print("v    : " + str(v))
